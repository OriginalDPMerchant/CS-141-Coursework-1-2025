<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8" /><meta name="viewport" content="width=device-width, initial-scale=1" /><title></title><link href="linuwial.css" rel="stylesheet" type="text/css" title="Linuwial" /><link rel="stylesheet" type="text/css" href="quick-jump.css" /><link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400i,700" /><script src="haddock-bundle.min.js" async="async" type="text/javascript"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { processClass: "mathjax", ignoreClass: ".*" } });</script><script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script></head><body><div id="package-header"><span class="caption empty">&nbsp;</span><ul class="links" id="page-menu"><li><a href="index.html">Contents</a></li><li><a href="doc-index.html">Index</a></li></ul></div><div id="content"><div id="description"><h1></h1><div class="doc"><h1>Halatro AI Approach</h1><p>The premise for my AI is that a rational person would only discard a hand if they have a &quot;good&quot; probability of getting a hand
with a higher score than their current hand.</p><h2>Calculating Probability of a Better Hand</h2><ul><li>We should be able to calculate the exact probability of getting a hand with a higher score by generating all possible hands and scoring them</li><li>We then count the number of hands with scores higher than our current hand and then divide that by the total number of combinations</li><li>Since we have access to the previously played/discarded cards this probability would reflect the current state of the game as we would exclude
  played hands from the list of combinations</li><li>However this would not be feasable as it would take too long to compute the scores for all of these combinations</li><li><p>For example, at the start of the game when no cards have been played we would need to compute the scores for x hands, where
    <span class="mathjax">\[x = \binom {52} {5} = 2598960 \]</span></p><h2>Estimating Probabilitties</h2><ul><li>To work around this limitation I estimate the probability of getting a higher scoring hand by estimating the probability of getting a better hand type. </li><li>The following calculations are used by <code>probabilityOfHand</code> to get the probabilities of getting certain hand types.</li><li>These Probabilitties are then summed by <code>probabilityOfImprovement</code> to give us the estimated probability of getting a higher scoring hand</li></ul><h3>Probability Of <code>None</code></h3><ul><li>Calculating the probability of getting a None is not important as it shouldn never happen if the game is working correctly</li></ul><ul><li>Hence we just return zero</li></ul><h3>Probability Of <code>HighCard</code></h3><ul><li>Calculating the probability of getting a HighCard is not important as it is the worst Hand Type so we don't care.</li></ul><ul><li>Hence we just return zero</li></ul><h3>Probability Of <code>Pair</code>, <code>ThreeOfAKind</code> and <code>FourOfAKind</code></h3><ul><li>To calculate the probability of getting w cards of the same rank when we sample without replacement z times from a population of size x with y 
    cards of the desired rank in the total population we use the Hypergeometric Distribution. (For <code>Pair</code>, <code>ThreeOfAKind</code> and <code>FourOfAKind</code> w is 2, 3 and 4 respectively)</li></ul><ul><li>We have 13 ranks... as we play the game these ranks will not all have the same number of cards in the population. This means that to calculate the probability of
    a <code>Pair</code>, <code>ThreeOfAKind</code> and <code>FourOfAKind</code> we should sum the probabilities given from the Hypergeometric Distribution for every rank</li></ul><h3>Probability Of <code>Flush</code></h3><ul><li>The same idea behind the probability for <code>Pair</code>, <code>ThreeOfAKind</code> and <code>FourOfAKind</code> but with suits instead of ranks</li></ul><h3>Probability Of <code>TwoPair</code></h3><ul><li>We Generate all possible combinations of two ranks</li></ul><ul><li>We then filter out the combinations where both ranks do not have a minimum of 2 cards of that rank in the population</li><li>For each rank pair (x, y) we calculate the number of ways of forming a <code>TwoPair</code> by: <span class="mathjax">\[\binom x 2 * \binom y 2 * (n-x-y)\]</span>,
    where n is the total number of cards in the population</li></ul><h3>Probability Of <code>FullHouse</code></h3><ul><li>We Generate all possible combinations of two ranks</li></ul><ul><li>We then filter out the combinations where one rank has less than 2 cards of that rank in the population and the other rank
    has less than 3 cards of that rank in the population</li><li>For each rank pair (x, y) we calculate the number of ways of forming a <code>FullHouse</code> by: <span class="mathjax">\[\binom x 2 * \binom y 3 \]</span></li></ul><h3>Probability Of <code>Straight</code></h3><ul><li>We calculate the total number of ways we can make a <code>Straight</code> and convert this to a probabaility by dividing by the total 
    number of cards in the population</li></ul><h3>Probability Of <code>StraightFlush</code></h3><ul><li>Probability Of <code>Flush</code> multiplied by Probability Of <code>Straight</code></li></ul><h3>Probability Of <code>RoyalFlush</code></h3><ul><li>We calculate the total number of ways we can make a <code>RoyalFlush</code> and convert this to a probabaility by dividing by the total 
    number of cards in the population</li></ul></li></ul><h2>Chosing Which Cards to Discard</h2><p>To keep things simple my AI will discard as many &quot;bad&quot; cards as possible. I found that counting anything with a rank less than Ten as a &quot;bad&quot; card
worked well</p><h2>What is a &quot;good&quot; Probability</h2><ul><li>To find a value for what would be considered a good probability I ran the AI for 100,000 runs and varied the minimum probability needed for a discard each time</li><li>I found that 0.01 gave the best results (average score of 691.05)</li><li>This result was interesting as it showed that the game of Halatro favoured high risk players on average</li></ul><p><img src="graphs.png" /></p></div></div><div id="module-list"><p class="caption">Modules</p><div id="module-list"><p class="caption"></p><ul><li><span class="module"><span class="noexpander">&nbsp;</span><a href="AuxiliaryFunctions.html">AuxiliaryFunctions</a></span></li><li><span class="module"><span class="noexpander">&nbsp;</span><a href="CourseworkOne.html">CourseworkOne</a></span></li><li><span class="module details-toggle-control details-toggle" data-details-id="n.3">Halatro</span><details id="n.3" open="open"><summary class="hide-when-js-enabled">Submodules</summary><ul><li><span class="module"><span class="noexpander">&nbsp;</span><a href="Halatro-Constants.html">Halatro.Constants</a></span></li><li><span class="module"><span class="noexpander">&nbsp;</span><a href="Halatro-Types.html">Halatro.Types</a></span></li></ul></details></li><li><span class="module"><span class="noexpander">&nbsp;</span><a href="ProbabilityFunctions.html">ProbabilityFunctions</a></span></li></ul></div></div></div><div id="footer"><p>Produced by <a href="http://www.haskell.org/haddock/">Haddock</a> version 2.27.0</p></div></body></html>